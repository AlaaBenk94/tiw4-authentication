Rapport de la partie B
======================
## Résumé
| fonctionnalités ou problemes                                                                                                                                                                                                                    | Solution mise ne place                                                                                                                                                                                                                                                                | Reference |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| L'utilisateur est obligé à reconnecter à  chaque expiration de token (60 secs)                                                                                                                                                                  | Pour maintenir la session utilisateur nous avons mis en place un mechanisme d'authentification a  base de refresh token qui permet de generer un  nouveau token pour l'utisateur dès l'expiration de l'ancien token.                                                                  |     Annexe[1]      |
| Mécanisme d'invalidation de token: les tokens JWT sont très difficiles à invalider, donc  si un malfaiteur qui est en possession de  refresh token aura accès au site jusqu'à l'expiration  de ce dernier. [`YOU CAN NOT SIMPLY LOGOUT WITH JWT`](https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6) | Nous avons implémenté un `blacklist des tokens`  qui permet de stocker les refresh tokens qui sont  invalidés (par exemple deconnection d'utilisateurs)  et n'ont pas encore expiré. Ensuite, pour chaque connexion,  on vérifie si le hêtre token est blacklisté.                    |     Annexe[2]      |
| les cookies où les tokens sont stockés peuvent  être intercepté ou volé. Cela permet au hacker  d'accéder facilement au site.                                                                                                                   | Nous avons parametrer les cookies pour : <br> Garantir que le navigateur n’envoie le cookie que sur HTTPS. <br>- Garantir que le cookie n’est envoyé que sur HTTP(S),  pas au JavaScript du client, ce qui renforce la protection contre  les attaques de type cross-site scripting.         |     Annexe[3]      |
| Les entrées d'utilisateurs n'étaient pas contrôlées  ce qui peut provoquer des attaques comme l'injection SQL, l'attaque brute force sur les mots de pass faibles et les  attaques DOS (mesures anti-botes).                                    | La solution proposée s'agit de contrôler les entrées utilisateur et donc : <br>- obliger l'utilisateur a taper un mot de pass fort  <br>- Empêcher l'utilisateur a choisi un mot de pass ou un email déjà utilisé <br>- mettre en place un catcha pour empêcher le Bot de creer plusieurs comptes |     Annexe[4]      |
| L'utilisateur, peut entrer le faux email pour creer plusieurs.                                                                                                                                                                                  | Mettre en place un processus de confirmation de mail qui envoie un mail de confirmation du compte crée.                                                                                                                                                                               |     Annexe[5]      |
| En cas de perte de mot de pass ou de piratage du compte.                                                                                                                                                                                        | Nous avons implémenté un processus qui permet aux utilisateurs de réinitialiser leurs mots de pass a l'aide de leurs emails.                                                                                                                                                          |     Annexe[6]      |
| Dans l'ancienne solution, n'importe quel utilisateur avait  l'accès à la liste des utilisateurs.                                                                                                                                                | Nous avons restreint l'accès à la liste des utilisateurs pour ne permettre que  les utilisateurs connectés d'y accéder.                                                                                                                                                               |     Annexe[7]      |
| L'utilisateur avait accédé au print de stack des erreurs  ce qui permet aux malfaiteurs d'utiliser les informations  de ces erreurs pour découvrir et exploiter les failles de  l'application                                                   | Cacher la stack d'erreurs aux utilisateurs et leur afficher, a sa place,  un simple message d'erreur.                                                                                                                                                                                 |      Annexe[8]     |

## Conclusion
Dans cette deuxième partie, nous avons implémenté plusieurs **features** qui permettent de sécuriser l'application ainsi que faciliter l'utilisation de l'application. Cependant, il reste un grand nombre de mesures et de fonctionnalité pour sécuriser l'application et assurer l'intégrité, la disponibilité et la confidentialité des données. De plus, l'expérience utilisateur est très basic, car on s'est concentré sur l'aspect sécurité de l'application et par fait de temps nous n'avons pas pu le mettre en place.
